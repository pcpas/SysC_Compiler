# SysC_Compiler

BUAA 编译技术大作业


# 代码优化

## 前言

**写代码优化真的很难。尤其是如果在前期自作聪明地用一些“简便方法”完成了代码生成，而没有保存足够的信息，或者生成的结构有问题的话，可能会非常非常痛苦。一定要保持头脑足够清醒。**

**此外，另一个重要的事情是保证优化之间相互兼容。有些优化可能会破坏原有的结构和信息，导致接下来的优化无法叠加上去，这一点一定要考虑清楚。**

**下面简单介绍一下我做的优化。**

## 中端优化

### 常量传播

**这个优化说实话比较简单，并且非常容易直接集成在代码生成时完成。基本思路为在代码生成时如果遇到可以计算的常量就直接算出来，而不是申请寄存器来存放常量计算的结果。此处不赘述。**

**值得注意的是常数数组的优化。不仅直接取其中元素时可以直接优化为常量，如果将常数数组作为参数传递给函数，函数中取其中的值也可以优化为常量。**

### 死代码删除

**死代码删除分为三步：**

1. **删除掉不可达基本块、函数。**
2. **构建定义使用链。**
3. **根据定义使用链删除掉无用的死代码。**

**删除死代码需要遍历有用函数中的每条指令，并沿着def-use链构建有用指令的****闭包**。最基本的一些有用指令包括alloc指令、br指令，ret指令，调用函数的call指令。

**寻找闭包的过程其实是一个递归：先将基本的有用指令进行标记，随后标记每条有用指令用到的value，并接着递归寻找其用到的value，从而构建一个有用指令的闭包。**

**然后将不在闭包内的所有指令全部删除即可。记得维护整体的数据结构的信息，因为之后还有别的优化要做。**

### 消除公共表达式

**我只做了基本块内的消除公共表达式。**

**消除公共表达式可以分为两步：**

1. **构建基本块的DAG图**
2. **根据DAG图导出指令**

### 窥孔优化

**我只做了比较简单的窥孔优化。**

**中端：**

1. **删除条件恒为假的**`br`指令。
2. **将条件恒为真的**`br`指令去掉条件，这样在翻译为mips时就不会翻译成`bnz。`

## 后端优化

### 寄存器分配

**设定**`s0-5`（或者任何你喜欢的寄存器）为全局寄存器，其他可用寄存器为临时寄存器。

**使用此前计算出的基本块的in和out集合构建冲突图，使用图着色算法为变量分配全局寄存器。**

**这里笔者只做到了基本块程度的冲突图，因此分配的精细度有欠缺，体现在竞速点里非常明显。因此建议还是做一下精确到每条指令的图着色，会对竞速的分数大有益处！**

### 窥孔优化

1. **删除没用的J指令。**
2. **优化for循环的基本块顺序以减少J指令。**
3. **删除形如**`addui $t1 $t1 0`或者`move $t0 $t0`的无用指令。
4. **合并冗余的指令。**

### 乘除模优化

* **乘法优化为对操作数为常数的指令进行优化，方法是乘法转换为左移和加法操作**
* **除法优化为将指令转化为乘法指令再进行乘法指令优化**
* **取模运算转化为乘除指令再优化：\$a \\ % \\ b = a -a/b\$**

### 其他的小优化

**还做了一些小优化，比如说MIPS叶子函数不需要保存ra；调用函数时只保存尽可能少的寄存器等，此处不一一列举。**

# 总结

**一开始在MIPS生成时写了一个简单的寄存器分配，没有引入全局寄存器，而是将全部的全局变量存入内存。我居然没有意识到这是不够的，反而觉得已经达到了最优，因此一直没有做最重要的图着色寄存器分配。后面意识到的时候已经来不及了，只能匆匆做一个简单版，效果很差。因此我认为优化一定要先做一些显然普适、有效的大优化，再慢慢由浅入深；此外先想好再动手也是很重要的一点。**
